# Proj-001: Compare between non-concurrent vs concurrent
- [Source](https://www.zenrows.com/blog/concurrency-c-sharp#what-is-concurrency-in-csharp)
- Write a scraper in many version, non-concurrent (synchoronous), Thread, Task

# Proj-002: Simple Thread

# Proj-003: Pass data to Thread Function
- [Source](https://dotnettutorials.net/lesson/how-to-pass-data-to-the-thread-function-in-a-type-safe-manner/)
- How to Pass data to the Thread function in C#?
- How to make the thread function type-safe in C#?
- ThreadStart and ParameterizedThreadStart delegates

# Proj-004: Retrieve Data from a Thread Function
- [Source](https://dotnettutorials.net/lesson/how-to-retrieve-data-from-a-thread-function)
- What is a Callback Method in C#?
- How does a callback method work in C#?
- How to retrieve data from a thread function using a callback method in C#?

# Proj-005: Join Method and IsAlive Property
- [Source](https://dotnettutorials.net/lesson/join-method-of-thread-class/)
- Understanding the need for Join Method of Thread Class in C#.
- Examples using different overloaded versions of the Join Method.
- Examples to Understand the use of IsAlive Property of Thread Class in C#.

# Proj-006: Thread Synchronization + Sample of Lock
- [Source](https://dotnettutorials.net/lesson/thread-synchronization-in-csharp/)
## What is Thread Synchronization in C#?
- Data inconsistency occurs when more than one threads access a shared resource such as in-memory data (instance or class variables) and external objects such as files at the same time.
- Example: Thread1 and Thread2, and both the threads access a shared resource let’s say Resource1 simultaneously. If Thread1 is trying to read data from the shared resource Resource1 when Thread2 is attempting to write data onto the shared resource Resource1, then there would be data inconsistency. Hence, in situations like this thread synchronization comes into the picture.
- Synchronization is a process that allows access to shared resources smoothly.
- Synchronization ensures that only one thread is accessing the shared resource at any given point in time, preventing other threads from doing the same at the same time.
## How Thread Synchronization is Achieved in C#?
- There're many ways: Lock, Monitor, Mutex, Semaphore, SemaphoreSlim

## What is Exclusive Lock and Non-Exclusive Lock in C#?
- When a process or a thread wants to access an object, it requests a lock on that object. There are two types of locks that determine access to shared resources – Exclusive Lock and Non-Exclusive lock.
### Exclusive Lock
- An exclusive lock makes sure that only one thread can gain access or enter a critical section at any given point in time.
- Implement Exclusive Lock using the lock keyword, Monitor class, Mutex Class, and SpinLock class.
### Non-Exclusive Lock
- Non-Exclusive locks provide read-only access to a shared resource and limit concurrency, i.e., limit the number of concurrent accesses to a shared resource.
- Implement Non-Exclusive Lock using the Semaphore, SemaphoreSlim, and ReaderWriterLockSlim classes.

# Proj-007: How to Protect Shared Resources in Multithreading using Monitor Class
- [Source](https://dotnettutorials.net/lesson/multithreading-using-monitor/)

## How does the Monitor Class work in C#?
- The Monitor class in C# provides a wait-based synchronization mechanism that allows only one thread to access the critical section code at a time to avoid the race condition.
- All the other threads must wait and halt the execution until the locked object is released.

## Difference Between Monitor and Lock in C#
- The Difference between monitor and lock in C# is that lock internally wraps the Enter and Exit methods in a try…finally block with exception handling.
- For the Monitor class in C#, we need to use the try and finally block explicitly to release the lock properly.
- So, Lock = Monitor + try-finally.

## Limitations of Locks and Monitors in C#
- The locks and monitors ensure thread safety for threads that are in process, i.e., the threads that are generated by the application itself, i.e., Internal Threads.
- But if the threads come from external applications (Out-Process) or External Threads, then Locks and Monitors have no control over them.
- So, in a situation like this, we need to use Mutex. In our next article, we will discuss Mutex.

# Proj-008: Mutex, Prevent multiple process access one codebase
- [Source](https://dotnettutorials.net/lesson/mutex-in-multithreading/)
- Mutex also helps us to ensure that our code is thread-safe.
- The Locks and Monitors ensure thread safety for threads that are InProcess i.e. the threads that are generated by the application itself i.e. Internal Threads.
- But if the threads are coming from OutProcess i.e. from external applications then Locks and Monitors have no control over them.
- Mutex ensures thread safety for threads that are Out-Process i.e. the threads that are generated by the external applications i.e. External Threads.

- Scenario: if create an console app, then build it. If click on the excution file .exe.
-  if you double-click multiple times, then each time a new external thread will be created and execute our application code as shown in the below image.
- But, if you want to restrict that only external thread access to our application code at any given point in time, then we need to use the Mutex in C#.

## Proj-008.v2: Mutex, Protect Shared Resource in Multithreading
## Proj-008.v3: Mutex, OpenExisting

- Note: Mutex only allows one external thread to access our application code. But if we want more control over the number of external threads to access our application code, then we need to use Semaphore Class

# Proj-009: Semaphore
- [Source](https://dotnettutorials.net/lesson/semaphore-in-multithreading/)
- Like Lock, Monitor, and Mutex the Semaphore is also used to provide thread safety in C# Multi-threaded Applications
- if we want more control over the number of external threads that can access our application code, then we need to use the Semaphore class
## What is Semaphore?
- The Semaphore Class in C# is used to limit the number of external threads that can have access to a shared resource concurrently.
- So, in real-time, we need to use Semaphore when we have a limited number of resources and we want to limit the number of threads that can use it.

## Proj-009.v1: Restrict the number of external threads to access the application
- In the below example, we are creating the semaphore instance to allow a maximum of two threads to access our application code i.e. the code in between the WaitOne method and Release method.

## Proj-009.v2: Protect shared resources in multithreading
- initialize a semaphore object with 2 initialcount and maximum of 3 threads that can enter the critical section.
- start the for loop with runs from 0 to 10. We started threads using the Thread class and the call shared resource DoSomeTask method.
- Each thread calls the WaitOne method of semaphore object before doing the required task.
- The WaitOne method will decrease the initialcount variable value by 1.
- So, the WaitOne method will limit the number of threads to access the shared resource.
- After completing the task each thread calls the Release method which will increment initialcount variable value by 1 of the semaphore object. This allows further threads to enter into a critical section.
- The result: maximum of two threads are entering the critical section and doing their tasks at any given point in time.

# Proj-010: SemaphoreSlim
- [Source](https://dotnettutorials.net/lesson/semaphoreslim-class-in-csharp/)
- SemaphoreSlim, like Lock, Monitor, ensure thread safety for threads that are in process.
- Using Lock and Monitor, only one internal thread can access our application code at any given point in time
- SemaphoreSlim allows control number of internal thread that can access our application code.
## Example 01
- created a Function called SemaphoreSlimFunction which gives access to a resource, the Wait method blocks the current thread until it can access the resource, and the Release method is required to release a resource once work is done.
- created five threads inside the Main method which will try to access SemaphoreSlimFunction simultaneously but we limited the access to three threads using the SemaphoreSlim object.

## Example 02
- create one SemaphoreSlim instance with a maximum count of three threads and an initial count of zero threads.
- the example then starts five tasks, all of which block waiting for the semaphore.
- The main thread calls the Release(Int32) overload to increase the semaphore count to its maximum, which allows three tasks to enter the semaphore.
- Each time the semaphore is released, the previous semaphore count is displayed.

# Proj-011: Deadlock
- [Source](https://dotnettutorials.net/lesson/deadlock-in-csharp/)
## Condition of deadlock occurrance:
- Mutual Exclusion: This implies that only one thread can access a resource at a particular time.
- Hold and Wait: This is a condition in which a thread holds at least one resource and waits for at least one resource already acquired by another thread.
- Circular Wait: This is a condition in which two or more threads are waiting for a resource acquired by the next member in the chain.

## Example:
- Cause a deadlock
- Avoid deadlock with Monitor.TryEnter
- Avoid deadlock by acquiring locks in a specific order

# Proj-012: ThreadPool
- [Source](https://dotnettutorials.net/lesson/thread-pooling/)

# Proj-013: Foreground vs Background Thread
- [Source](https://dotnettutorials.net/lesson/foreground-and-background-threads-in-csharp/)

## Foreground Thread
- Foreground threads are those threads that keep running even after the main application exits or quits.
- The foreground thread has the ability to prevent the current application from terminating.
- The main thread is a foreground thread.
- Note: By default, when we created a thread in C#, it is a Foreground thread.

## Background Thread
- Background Threads are those threads that will quit if our main application quits.
- Background threads are viewed by the CLR and if all foreground threads have terminated, then all the background threads are automatically stopped when the application quits.

## Example of Foreground Thread
- after the main thread or main method completes its execution, still the Foreground Thread is running. So, this proves that Foreground threads keep running and complete their tasks even after the application exits or quits i.e. even after the main thread quits.
## Example of Background Thread
- In the above example, as soon as the main thread quits the background thread also quit.
## Example of Multiple Foreground Threads and one Background Thread
- The main thread is by default a foreground thread
- From the main thread creates a foreground thread1 object to call Method1.
- Then from Method1, we created a background thread to call Method2.
- Here, once all the foreground threads i.e. Main thread and thread1 quit
	then automatically the background thread i.e. thread2 quits the application
	without completing its task (sometimes the task might be completed).

# Proj-014: Signalling Methodology, AutoResetEvent and ManualResetEvent
- [Source](https://dotnettutorials.net/lesson/autoresetevent-and-manualresetevent-in-csharp/)
- Using the Signalling Methodology we can implement thread synchronization between multiple threads
- both AutoResetEvent and ManualResetEvent in C# help us to achieve this

## AutoResetEvent
### Example:
- Has 2 thread, MainThread + NewThread
- MainThread will invoke main method
- NewThread will invoke SomeMethod
- The main method will invoke the new thread and the new thread actually go and run the SomeMethod.
- the SomeMethod will first print the first statement i.e. Starting…
	then it invokes the WaitOne() method which Put the current thread i.e.NewThread into the waiting state until it receives the signal.
- Then inside the static void Main method, when we press the enter key, it will invoke the Set method which will send a signal to other threads to resume their work
	i.e. send the signal to NewThread to resume its work
- and the new thread then prints Finishing…….. on the console window.

## ManualResetEvent
### Example
- Same as example of AutoResetEvent

## Difference between AutoResetEvent vs ManualResetEvent
- AutoResetEvent, each WaitOne method there should be a corresponding Set method
- ManualResetEvent, one Set Method can release all WaitOne methods.

# Proj-015: Thread Life Cycle
- [Source](https://dotnettutorials.net/lesson/thread-life-cycle-in-csharp/)
- not useful

# Proj-016: Threads Priorities
- [Source](https://dotnettutorials.net/lesson/threads-priorities-in-csharp/)
- Obsoleted

# Proj-017: Terminate a Thread
- [Source](https://dotnettutorials.net/lesson/how-to-terminate-a-thread-in-csharp/)
- Obsoleted

# Proj-018: Inter Thread Communication
- [Source](https://dotnettutorials.net/lesson/inter-thread-communication-in-csharp/)
- Inter-thread Communication in C# is a mechanism of communication between two or more threads that work on the shared resource.
- Can use the Monitor Class to perform inter-thread communication
- Wait(), Pulse(), and PulseAll() are useful methods are used to perform inter-thread communication

## Example 01, Use Wait(), Push() to implement fn print the Even and Odd number
- Requirement is to print the Even and Odd number sequence using 2 different threads.
- So, One thread will print the even numbers and another thread will print the odd numbers.
` code
	Thread T1: 0,2,4,6,8…
	Thread T2:1,3,5,7,9…
	Output: 0,1,2,3,4,5,6,7,8,9…
`
### Step of process
- First, the Even thread will start to print the number on the console.
- Then the Even thread will signal the Odd thread to print the number using the Monitor.Pulse() method.
- Again, the Even thread will wait for a signal from the Odd thread using Monitor.Wait() method.
- The same thing will also be done by the Odd Thread.
- The Odd thread will start to print the number on the console.
- Then the Odd thread will signal the Even thread to print the number using Monitor.Pulse() method.
- Again, the Odd thread will wait for the signal from the Even thread using Monitor.Wait() method.
- The same process is going on.

## Example 02, 
- Got 2 thread, MainThread and a Manual Thread
- The manually created new thread will print a table of 4
- the Main Thread will print a table of 5.
- But, without using the Wait() and Pulse() methods,
	when two threads start at almost the same time,
	The Main Thread may print the table of 5 before the manually created thread has printed the table of 4.

### Explain the output
- the Main thread enters the synchronized block, gets the lock on the _lockObject,
	and gets its synchronized sole access to print the table of 5. It then releases the lock on the _lockObject.
- In the PrintTable method, Manual Thread enters the synchronized block and gets the lock on the same _lockObject.
	It then prints the table of 4.
	Hence, table 5 is printed before table 4, bothering our ascending order,
	because there was no interthread communication.

# Proj-019
## Example Execute multi tasks
- [Source](https://dotnettutorials.net/lesson/how-to-execute-multiple-tasks-in-csharp/)
### Example Execution with Task.WhenAll Method
- Sample02ExecuteMultipleTasksV1
### Example Execution without Task.WhenAll Method
- Sample02ExecuteMultipleTasksV2
### Example Offloading the Current Thread – Task.Run Method
- Sample02ExecuteMultipleTasksV3
## Limit Number of Concurrent Tasks - Using SemaphoreSlim
- [Source](https://dotnettutorials.net/lesson/how-to-limit-number-of-concurrent-tasks-in-csharp/)
- Sample03SemaphoreSlim
## Cancel a Task
- [Source](https://dotnettutorials.net/lesson/how-to-cancel-a-task-in-csharp/)
### Example 01, using CancelToken
- Sample04UseCancelToken

## Create Synchronous Method using Task
- [Source](https://dotnettutorials.net/lesson/how-to-create-synchronous-method-using-task-in-csharp/)
- Sample05ImplementSynchronousMethodUsingTask

### Where to use
- If there's a method with an asynchronous signature, that is return Task
	, but its implementation will be Synchronous.
	One reason for this is that you have to implement a basic interface that returns a task and the implementation is synchronous.
- Another reason, in your unit tests you need to mock asynchronous methods.
	And the implementation is going to be synchronous.

=> To solve these problems, we can use axillary methods like CompletedTask, FromResult, FromException, and FromCanceled.

## Example Retry Pattern in Asynchronous Programming
- [Source](https://dotnettutorials.net/lesson/retry-pattern-in-csharp/)
- Use in below scenarios:
	Handling Transient Failures
	Interacting with External Services
	Database Operations
	Resilience in Microservices
	File I/O Operations
	Queueing Systems and Messaging
- Sample06RetryPatterns

## Example Only One Pattern in Asynchronous Programming
- [Source](https://dotnettutorials.net/lesson/only-one-pattern-in-csharp/)
### Scenario
- Sometimes we will have multiple tasks, and all the tasks give us the same information,
	and we only want to use the first one to finish and cancel the rest.
- For that, we can use a pattern (Only One Pattern) that uses the cancellation token.

### Example of Only One pattern
- Have ProcessingName is an asynchronous method
	takes two parameters i.e. name and cancellation token.
	Then here we delay the execution for a random period of time between 1 to 10 seconds.
	And finally, we return the name by appending the Hello word.
- This method is going to call multiple times
	we don’t know for which call it will delay the execution for how much time as the waiting time generates randomly.
- Using CancelToken + WhenAny
- Sample07OnlyOnePatternsV1

### Example enhance Only One Pattern with Generic Method
- Sample07OnlyOnePatternsV2

## Control the Result of a Task
- [Source](https://dotnettutorials.net/lesson/how-to-control-the-result-of-a-task-in-csharp/)

### Scenario
- If we're working with tasks, and task status depends on an event.
- For example, if we make an HTTP request or if we make an Async method call,
	then the status of the task is associated with what happens with the HTTP Request or with the Async Method call,
	whether it is successful,
	or there is an exception
	or the operation is canceled using a cancellation token.
- With TaskCompletionSource, can create a task for which we are the ones who will control its status,
	whether it is successful, canceled, or if it’s thrown an exception.
	
### Example to Understand How to Control the Result of a Task
- created one method which is returning a Task and taking a string input value.
- First, we created an instance of the TaskCompletionSource class using one of the overloaded versions of the Constructor.
- Then we are checking the string value using if-else statements.
	If the input string value is 1 then we are calling the SetResult method on the TaskCompletionSource instance
		this method will set the state of the Task (the task holds by the TaskCompletionSource object) to RanToCompletion.
	Next, if the string value is 2, then we are calling the SetCanceled method which will set the state of the Task to Canceled.
	If the value is neither 1 nor 2, then we are calling the SetException method by passing an exception object which will set the state of the Task to Faulted.
- Finally, we are returning the task by calling the Task property of the TaskCompletionSource class.
- Sample08TaskCompletionSource

## Chaining Tasks by Using Continuation Tasks
- [Source](https://dotnettutorials.net/lesson/chaining-tasks-by-using-continuation-tasks/)

### Scenario
- While working with asynchronous programming,
	it is very common to invoke one asynchronous operation from another asynchronous operation passing the data once it completes its execution.
	This is called continuations
- in the traditional approach, this has been done by using the callback method which is a little difficult to understand.
- With Task Parallel Library (TPL), the same functionality can be achieved very easily by using continuation tasks. ContinueWith()

### Example Creating a continuation for a single antecedent
- Sample09TaskContinuationV1

### Example Scheduling Different Continuation Tasks
- Sample09TaskContinuationV2

## How to Attached Child Tasks to a Parent Task
- [Source](https://dotnettutorials.net/lesson/how-to-attached-child-tasks-to-a-parent-task-in-csharp/)

### Defination
- A Child Task (or nested task) is a Task that is going to be created by another task called the parent task.
	A Child Task can be either detached or attached.
- A detached child task is a task that executes independently of its parent.
	In this case, both parent and child are going to be executed independently 
		and the parent will not wait for the Child Task to complete its execution.
	If any exception is thrown by the child task, then that is not going to be handled by the Parent task.
	The Parent Task status does not depend on the Child Task status.
- An attached child task is a nested task that is created with TaskCreationOptions.AttachedToParent option.
	In this case, the parent will wait for the Child task to complete its execution.
	If any exception is thrown by the child task, then that is going to be handled by the Parent task.
	The Parent task status depends on the Child task status.
- In most of the scenarios, it is recommended to use detached child tasks
- So, Tasks created inside the parent tasks are detached by default

### Example Demo Detached Child Tasks
- Sample10DetachedChildTasks
### Example Demo Attached Child Tasks
- Sample10AttachedChildTasks

## ValueTask
- [Source](https://dotnettutorials.net/lesson/valuetask-in-csharp/)
- When to use:
	It is recommended to use Task or Task<T> in general and only use ValueTask
		and ValueTask<T> when performance measurements justify it
		, which may be the case in High-performance scenarios.

## How to Cancel a Non-Cancellable Task
- [Source](https://dotnettutorials.net/lesson/how-to-cancel-a-non-cancellable-task-in-csharp/)
- non-Cancellable tasks
	, mean asynchronous methods which do not receive a cancellation token
	, and therefore we cannot cancel using a token unless we write custom logic to achieve it.
- use TaskCompletionSource to create a simple task that we will be able to cancel with a token.
- Sample11CancelANonCancellableTasks

# Proj-020: Asynchronous Streams
- [Asynchronous Streams](https://dotnettutorials.net/lesson/asynchronous-streams-csharp/)
- [Cancel a Asynchronous Streams](https://dotnettutorials.net/lesson/how-to-cancel-asynchronous-stream-in-csharp/)

# Proj-021: Task Parallel Library
## Concepts
- [Source](https://dotnettutorials.net/lesson/task-parallel-library-overview/)

### What is Parallel Programming in C#?
- Parallel Programming in C# helps us divide a task into different parts and work those parts simultaneously
	An example might be that we have a set of credit cards and we want to process them simultaneously.
	Or if we have a set of images and we want to apply a series of filters to each one
- In C#, we mainly use two tools to work with parallelism.
	The Task Parallel Library (TPL)
	Parallel LINQ (PLINQ)
- Note, while working with Parallel Programming
	The Tasks must be independent.
	The order of the execution does not matter
- C# Supports Two Types of Parallelism
	Data Parallelism, occurs when we have a collection of values and we want to use the same operation on each of the elements in the collection.
		Parallel.For
		Parallel.ForEach
		Example: 
	Task Parallelism, occurs when we have a set of independent tasks that we want to perform in parallel.
		Parallel.Invoke
		Example: send email and sms at the same time, two tasks are independent

## Parallel For
- [Source](https://dotnettutorials.net/lesson/parallel-for-method-csharp/)

### What is the Difference Between the Parallel For loop and Standard C# for loop?
- The standard loop will run using a single thread, whereas, Parallel For loop will execute using multiple Thread
- The standard loop is iterated in sequential order, whereas, Parallel For loop, the order of the iteration is not going to be in sequential order.

### Compare Standard Loop vs Parallel For Loop
- Sample01CompareStandardLoopVsParallelForLoop
- Sample02CompareStandardLoopVsParallelForLoop

### Example to Understand MaxDegreeOfParallelism
- Sample03MaxDegreeOfParallelism

### Terminating a Parallel For Loop
- Sample04TerminateAParallelLoop

### Considerations and Best Practices
- Thread Safety: Ensure that your loop code is thread-safe.
	Avoid modifying shared data without proper synchronization mechanisms like locks, concurrent collections, or other thread synchronization techniques.
- Order of Execution: The iterations of a Parallel For loop do not run in a guaranteed order, and different iterations may run simultaneously.
	This is different from a regular for loop where each iteration runs sequentially.
- Exception Handling: Handling exceptions in a Parallel For loop can be more complex.
	You might use a ParallelLoopState object to stop or break the loop, and an AggregateException may be thrown if multiple iterations throw exceptions.
- Performance: While Parallel.For can improve performance for CPU-bound operations, it might not be beneficial for I/O-bound operations.
	Additionally, for very short or simple loop bodies, the overhead of parallelization may outweigh its benefits.
- Cancellation Support: Parallel.For support task cancellation using the CancellationToken class.
	This can be useful for long-running operations that need to be stopped under certain conditions.
- Return Values and Loop Control: Parallel.For returns, a ParallelLoopResult which can be used to determine if the loop ran to completion or was stopped/prematurely exited.
	You can also control the loop execution using the ParallelLoopState object in the loop body.

## Parallel Foreach
- [Source](https://dotnettutorials.net/lesson/parallel-foreach-method-csharp/)
- Sample05StandardForeachVsParallelForeach;
- Sample06StandardForeachVsParallelForeach;

## Parallel Invoke
- [Source](https://dotnettutorials.net/lesson/parallel-invoke-method-csharp/)
- Sample07SequentialTaskVsParallelInvoke

### Invoking Methods with Input and Return Type using Parallel.Invoke
- Sample08ParallelInvokeWithInputAndReturn

## Maximum Degree of Parallelism
- [Source](https://dotnettutorials.net/lesson/maximum-degree-of-parallelism-in-csharp/)
- Sample09MaxDegreeOfParallelism

## Cancel Parallel Operations
- [Source](https://dotnettutorials.net/lesson/cancel-parallel-operations-in-csharp/)
- Sample10CancelAParallelInvoke
- Sample11CancelAParallelForeach

## Atomic Methods Thread Safety and Race Conditions
- [Source](https://dotnettutorials.net/lesson/atomic-methods-thread-safety-and-race-conditions-in-csharp/)
- Sample12SolveRaceCoditionProblem

## More Sample of Interlocked vs lock
- [Source](https://dotnettutorials.net/lesson/interlocked-vs-lock-in-csharp/)

## Parallel LINQ
- [Source](https://dotnettutorials.net/lesson/parallel-linq-in-csharp/)
- Sample13StandardLinqVsParallelLinq
- Sample14ParallelLinqCancelationAndMaximumDegree
- Sample15ParallelLinqAggregate

### Points to Remember When Working with PLINQ
- Ordering: PLINQ processes elements in parallel and doesn’t guarantee the order of the results
	unless you explicitly ask for it using the AsOrdered method.
	Preserving order can add overhead and potentially reduce performance gains.
- Side Effects: Queries should be side-effect-free.
	Since PLINQ can process multiple elements simultaneously,
	using functions that have side effects can result
	in unexpected behavior or race conditions.
- Exception Handling: When an exception is thrown in a PLINQ query, it is wrapped in an AggregateException.
	This exception contains all the individual exceptions thrown during the execution of the query.
- Performance: Not all queries run faster in parallel. 
- Forcing Parallelism: You can force PLINQ to parallelize the query
	using the WithExecutionMode method with ParallelExecutionMode.ForceParallelism
	is not recommended
- Degree of Parallelism: You can specify the number of processors to use in a PLINQ query by using the WithDegreeOfParallelism method.

### When to Use Parallel LINQ
- Large Data Sets
- CPU-Intensive Operations
- Multi-Core Processors
- Long-Running Queries

### When to Use Parallel LINQ
- Small Data Sets
- I/O-Bound Operations
- Ordered Queries
- Non-Thread-Safe Operations
- Asynchronous Operations

# Compare Multithreading vs. Asynchronous Programming vs. Parallel Programming
- [Source](https://dotnettutorials.net/lesson/multithreading-vs-asynchronous-programming-vs-parallel-programming-in-csharp/)
- Multithreading: This is all about a single process split into multiple threads.
- Parallel Programming: This is all about multiple tasks running on multiple cores simultaneously.
- Asynchronous Programming: This is all about a single thread initiating multiple tasks without waiting for each to complete.
- IO-Bound Operations: Asynchronous programming is best suited for IO-Bound Operations.
- CPU-Bound Operations: Parallel Programming and Multithreading best suitable for CPU-Bound Operations.


# Concepts
- [Source](https://dotnettutorials.net/lesson/constructors-of-thread-class-csharp/)
## Multitasking
- Multitasking refers to the concurrent execution of multiple tasks or processes on a computer system.
- Windows Operating System is a multitasking operating system. It has the ability to run multiple application at the same time.

## Process
- A process is a part of the operating system responsible for executing the program or application.

## Thread
- A Thread is a unit of a process that is responsible for executing the application code.

## Multithreading in C#
- Multithreading is a mechanism to implement Concurrent Programming where multiple threads operate simultaneously.

## Key Features of Multithreading in C#
### Thread Class
- C# provides the System.Threading.Thread class, which allows you to create and manage threads.

### Parallel Programming
- Multithreading is often used for parallel programming, where multiple threads work on separate parts of a problem to improve performance.
- Task Parallel Library (TPL) and Parallel LINQ (PLINQ) are library provided to simplify parallel programming.
### Thread Safety
- When multiple threads access shared data or resources, it’s crucial to ensure thread safety to prevent data corruption and race conditions.
- C# provides synchronization primitives like locks, mutexes, semaphores, and the Monitor class to help you achieve thread safety.

### Async/Await
- C# includes the async and await keywords, simplifying asynchronous programming.
- These keywords allow you to write asynchronous code that can run concurrently with other tasks without blocking the calling thread. Asynchronous programming is essential for scalable and responsive applications.

## IO-bound operations
- IO-bound ops are those that depend on communication with entities external to our application.

## Main properties & methods of Thread Class
### Properties
- CurrentThread
- IsAlive
- IsBackground
- ManagedThreadId
- Name
- Priority
- ThreadState
- IsThreadPoolThread
### Methods
- Abort()
- Interrupt()
- Join()
- ResetAbort()
- Resume()
- Sleep()
- Start()
- Suspend()
- Yield()

## How to Debug a Multi-threaded Application in C#
- [Source](https://dotnettutorials.net/lesson/how-to-debug-a-multi-threaded-application-in-csharp/)
- Use debug condition or via Debug => Windows => Threads
